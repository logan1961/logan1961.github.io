[{"title":"Oracle存储过程实例","url":"%2F2019%2F08%2F01%2Flog16procedure%2F","content":">存储过程(Stored Procedure)是一组用于完成特定数据库功能的SQL语句集，SQL集包含了所要进行的各种处理，经过编译后存储在数据库系统中。在使用时候，用户通过指定已经定义的存储过程名字并给出相应的存储过程参数来调用并执行它，得到想要的结果。\n使用工具：plsql、Oracle\n\nOracle存储过程保存在数据库procedures下，基本写法如下：\n**1.基本结构**\n```\nCREATE OR REPLACE PROCEDURE 存储过程名称  \n IS  //声明  \n ;  \n BEGIN \t// 执行  \n\t\t//要实现的逻辑功能\n ;  \n EXCEPTION//存储过程异常操作  \n ;  \n END 存储过程名称;  \n```\n\n在存储过程(PROCEDURE)和函数(FUNCTION)中没有区别；\n在视图(VIEW)中只能用AS不能用IS；\n在游标(CURSOR)中只能用IS不能用AS\n**2. 无参的存储过程**\n```\n//新建了一个无参的存储过程，输出procedure testeeee11\nCREATE OR REPLACE PROCEDURE TEST1 IS\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('procedure testeeee11');\nEND TEST1;\n\n//调用你的存储过程\nDECLARE\nBEGIN\n  TEST1;\nEND;\n```\n\n按F8执行编译后，存储过程不能直接执行，新建一个测试窗口，调用存储过程，按F8执行即可在输出中看到结果。\n**3. 有参的存储过程**\n```\n//模糊查询到结果的数量\nCREATE OR REPLACE PROCEDURE TEST4(TSKNAME IN NVARCHAR2, COUNTS OUT NUMBER) IS\nBEGIN\n  SELECT COUNT(*) INTO COUNTS FROM TASK_INFO WHERE TASKNAME LIKE '%'||TSKNAME||'%';\nEND TEST4;\n\n//调用存储过程，传入对应的参数\nDECLARE \n  COUNTS NUMBER;\nBEGIN\n  TEST4('假',COUNTS);\n  DBMS_OUTPUT.PUT_LINE('符合条件的数量为：'||COUNTS);\nEND;\n```\n其中存储过程的参数分为in、out和in out三种模式\nin:用于接收参数，在子程序内部，不能进行修改\nout:表示返回值参数\nint out:表示该参数可以向该过程中传递值，也可以将某个值输出\n\n**4. if判断：**\n```\n//添加if判断\nCREATE OR REPLACE PROCEDURE TEST5(TSKNAME IN NVARCHAR2,COUNTS OUT NUMBER,MESSAGE OUT NVARCHAR2) AS\nBEGIN\n  SELECT COUNT(*) INTO COUNTS FROM TASK_INFO WHERE TASKNAME LIKE '%'||TSKNAME||'%';\n  IF COUNTS >5 THEN\n    BEGIN \n       MESSAGE:= '相似数据过多';\n    END;\n  END IF;\n  IF COUNTS <2 THEN\n    BEGIN\n      MESSAGE:='数据量不足';\n    END;\n  END IF;\nEND TEST5;\n//调用\nDECLARE \n  COUNTS INT:=0;\n  MESSAGE NVARCHAR2(20);\nBEGIN\n  TEST5('假数据1',COUNTS,MESSAGE);\n  DBMS_OUTPUT.PUT_LINE('查询到的数量为：'||COUNTS);\n  DBMS_OUTPUT.PUT_LINE('输出的信息为：'||MESSAGE);\nEND;\n```\n**5. loop循环：**\n```\n//使用循环\nCREATE OR REPLACE PROCEDURE TEST5(COUNTS OUT NUMBER) AS\nNUM INT;\nBEGIN\n  NUM:=0;\n  SELECT COUNT(*) INTO COUNTS FROM TASK_INFO WHERE ID = NUM;\n  WHILE NUM < 10 LOOP\n    BEGIN\n      SELECT COUNT(*) INTO COUNTS FROM TASK_INFO WHERE ID = NUM;\n      DBMS_OUTPUT.PUT_LINE('我已经执行了一次：'||NUM);\n      NUM:= NUM+1;\n      COUNTS:= NUM;\n  END;\n  END LOOP;\nEND TEST5;\n\n//调用\nDECLARE \n  COUNTS INT:=0;\nBEGIN\n  TEST5(COUNTS);\n  DBMS_OUTPUT.PUT_LINE('最终的数量为：'||COUNTS);\nEND;\n```\n\n**6. 对数据库的添加**\n```\nCREATE OR REPLACE PROCEDURE TEST_ADD\n(ID NUMBER,CREATETIME DATE,TASKNAME VARCHAR,\nCONTENT VARCHAR,REMARK VARCHAR)\nIS\nBEGIN\n  INSERT INTO TASK_INFO VALUES(ID,TASKNAME,CONTENT,REMARK,CREATETIME);\nCOMMIT;//提交事务\nEND TEST_ADD;\n```\n**7. 异常处理：**\n```\nEXCEPTION\nWHEN 异常类型 THEN \nRAISE_APPLICATION_ERROR(-20010, '提示信息');\nWHEN 异常类型 THEN \nRAISE_APPLICATION_ERROR(-20011, '提示信息');\n```\n更多关于异常处理参考：[Oracle存储过程的异常处理](https://www.cnblogs.com/liuguanghai/p/5460825.html)\n","tags":["Oracle"],"categories":["Oracle"]},{"title":"关于Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required报错解决","url":"%2F2019%2F04%2F22%2Flog15myBatis1%2F","content":"最近在做毕设的时候，看到网上有个不错的项目，本地初始化搭建项目的时候遇到一个错误，困扰了大半天时间。\n报错信息如下：\n<!-- more -->\n\n```\n22-Apr-2019 14:43:37.205 警告 [RMI TCP Connection(3)-127.0.0.1] org.springframework.web.context.support.XmlWebApplicationContext.refresh Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'ArticleService': Unsatisfied dependency expressed through field 'articleDao'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'ArticleDao' defined in file [G:\\myProject\\myBlog\\target\\myBlog\\WEB-INF\\classes\\com\\logan\\blog\\dao\\impl\\ArticleDaoImpl.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required\n22-Apr-2019 14:43:37.207 严重 [RMI TCP Connection(3)-127.0.0.1] org.springframework.web.context.ContextLoader.initWebApplicationContext Context initialization failed\n org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'ArticleService': Unsatisfied dependency expressed through field 'articleDao'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'ArticleDao' defined in file [G:\\myProject\\myBlog\\target\\myBlog\\WEB-INF\\classes\\com\\logan\\blog\\dao\\impl\\ArticleDaoImpl.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588)\n\tat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)\n\tat org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:443)\n\tat org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:325)\n\tat org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:107)\n\tat org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4753)\n\tat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5215)\n\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n\tat org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:754)\n\tat org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730)\n\tat org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)\n\tat org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1736)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819)\n\tat com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)\n\tat org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:482)\n\tat org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:431)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819)\n\tat com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)\n\tat javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1468)\n\tat javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:76)\n\tat javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1309)\n\tat javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1401)\n\tat javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:829)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:361)\n\tat sun.rmi.transport.Transport$1.run(Transport.java:200)\n\tat sun.rmi.transport.Transport$1.run(Transport.java:197)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.rmi.transport.Transport.serviceCall(Transport.java:196)\n\tat sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:568)\n\tat sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:826)\n\tat sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:683)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:682)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n主要错误信息为：`Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required`\n涉及到的代码如下：\n```\n@Repository(\"ArticleDao\")\npublic class ArticleDaoImpl extends SqlSessionDaoSupport implements ArticleDao {\n   ......\n}\n```\n错误的主要原因为在Dao的实现类中继承了`SqlSessionDaoSupport`来实现SqlSessionFactory的自动注入，然后通过this.getSqlSession()拿到SqlSession。\n但是这种写法在mybatis-spring整合包的版本为1.2.0之前是没有问题的，但后续的版本取消了自动注入，当引入的依赖包版本大于1.2.0后就会报错。\n\n解决方法：\n创建一个适用于所有Dao的基类CommonDao，通过CommonDao来继承SqlSessionDaoSupport，通过set方法注入SqlSessionFactory，这样就不会报错了。\n写法如下：\n```\npublic class CommonDao extends SqlSessionDaoSupport{\n\n    @Resource\n    public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {\n        super.setSqlSessionFactory(sqlSessionFactory);\n    }\n}\n```\n使用时再将继承换成CommonDao即可：\n```\npublic class ArticleDaoImpl extends CommonDao implements ArticleDao {\n\t......\n}\n```","tags":["Java"],"categories":["Java"]},{"title":"HttpURLConnection的使用","url":"%2F2019%2F03%2F15%2Flog14http%2F","content":"## 两种请求方式\nURL请求通常有两种方式：GET请求和POST请求\n\t**GET请求**的数据会附在URL之后，通过?来拼接所传的参数，参数之间以&相连。请求中发送的参数如果是字母或者数字则按照原样发送，空格则转换为+，中文或者其他字符则按照base64位加密，得到`%E4%BD%A0%E5%A5%BD`类似的形式，其中%xx为该符号以16进制表示的ASCII码。\n​\t**POST请求**的参数不是放在URL字符串里面，而是放在HTTP请求的正文内，请求的参数被封装起来以流的形式发送给服务端。\n    ​\t<!-- more -->\n\n    两者主要的区别：GET请求参数直接拼接在URL后面，隐私性较差，长度可能会受限制，GET请求能够被缓存，一般请求的默认为GET；POST请求通过实体内容传参数隐私性好，大小没有限制，POST请求不能被缓存下来，需要声明采用POST。\n    一般，Get是向服务器索取数据的一种请求，而Post是向服务器提交数据的一种请求。\n\n## HttpURLConnection使用\nHttpURLConnection它继承自URLConnection，可用于向指定网站发送GET请求、POST请求。\n```\nURL url = new URL(\"URL\");\nHttpURLConnection connection = (HttpURLConnection) url.openConnection();\nconnection.setDoOutput(true);\nconnection.setDoInput(true);\nconnection.setUseCaches(false);\nconnection.setInstanceFollowRedirects(true);\n```\n>1.通过调用URL.openConnection()来获得一个新的HttpURLConnection对象,结果强制转换为HttpURLConnection\n>2.准备请求。参数为URI。请求头可能也包含元数据，例如证书或者约定好的请求内容。\n>3.可以选择性的上传一个请求体。HttpURLConnection实例必须设置`setDoOutput(true)`，如果它包含一个请求体。通过将数据写入一个由getOutStream()返回的输出流来传输数据。\n>4.读取响应。响应头通常包含元数据例如响应体的内容类型和长度，修改日期和会话cookies。响应体可以被由getInputStream返回的输入流读取。如果响应没有响应体，则该方法会返回一个空的流。\n>5.关闭连接。一旦一个响应体已经被阅读后，HttpURLConnection 对象应该通过调用disconnect()关闭。断开连接会释放被一个connection占有的资源，这样它们就能被关闭或再次使用。\n\n## 步骤：\n### 创建url实例（基本固定）\n```\nURL url=new URL(\"请求的url\");\nHttpURLConnection connection= (HttpURLConnection) url.openConnection();\n```\n### 连接设置\n```\nconnection.setRequestMethod(\"POST\");//设置请求方式，默认为GET\nconnection.setDoOutput(true);//设置是否向httpUrlConnection输出，post请求，参数要放在http正文内，需要设为true； 默认情况下是false。\nconnection.setDoInput(true);//是否从httpUrlConnection读入，默认情况下是true; \nconnection.setUseCaches(false);//设置是否使用缓存，Post请求不能缓存 \nconnection.setInstanceFollowRedirects(true);//设置超时时间\n```\n### 设置请求头参数\n```\nconnection.setRequestProperty(\"Accept\", \"application/json\");\nsetRequestProperty（key，value）;\naddRequestProperty(key,value);\n```\nsetRequestProperty会覆盖已经存在的key的所有values，有清零重新赋值的作用。而addRequestProperty则是在原来key的基础上继续添加其他value。\n### 发送请求\n```\nconnection.connect();\ngetOutputStream\n```\ngetOutputStream会隐含的进行connect(等同于调用上面的connect()方法， 不调用connect()也可以) \n\n### 获取响应\n```\nconnection.getContent()\nconnection.getInputStream()\nconnection.getHeaderField ()\n```\n对于大部分请求，getInputStream和getContent最常用。\n","tags":["Java"],"categories":["Java"]},{"title":"Oracle数据库快速扫盲","url":"%2F2019%2F03%2F04%2Flog13oraDB%2F","content":"之前只用过MySQL数据库，在第一次接触Oracle数据库时很多不一样的概念很困惑，通过网上查询资料对Oracle有了一定的了解。\n\n这篇主要包括Oracle的一些概念，包括简单的sql语句，关于sql语法还会再总结一篇...\n<!-- more -->\n\n## Oracle和MySQL的区别\n- Oracle默认端口：1521 默认用户为System；MySQL默认端口3306 默认用户root\n- Oracle语法较为严格，MySQL语法灵活\n- Oracle是通过表空间管理；MySQL不是\n\n## Oracle数据库的一些概念\n\n### \"数据库\"\nOracle数据库是数据的物理存储，包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件），Oracle数据库的概念和其他数据库不同，这里的数据库是一个操作系统只有一个库，包含物理数据、数据库管理系统（即物理数据、内存、操作系统进程的组合体），可以理解为Oracle只有一个大数据库。\n\n### \"数据库实例\"\n一个数据库可以有n个实例\n> Oracle官方描述：实例是访问Oracle数据库所需的一部分计算机内存和辅助处理后台进程，是由进程和这些进程所使用的内存(SGA)所构成一个集合。其实就是用来访问和使用数据库的一块进程，它只存在于内存中。就像Java中new出来的实例对象一样。我们访问Oracle都是访问一个实例，但这个实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误。\n\n### \"数据文件\"\n数据文件是数据库的物理存储单位，数据库的数据存储在表空间中，实际上真正存储在某一个或多个数据文件中。\n一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。**一旦数据文件被加入到某个表空间，就不能删除这个文件，如果要删除某个数据文件，只能删除对应的表空间。**\n\n### \"表空间\"\n表空间是一个用来管理数据存储逻辑概念，表空间只是和数据文件（ORA或者DBF文件）发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间，一个表空间只能属于一个数据库。\nOracle数据库是通过表空间来存储物理表的，一个数据库实例可以有N个表空间，一个表空间下可以有N张表。有了数据库，\n就可以创建表空间。\n表空间(tablespace)是数据库的逻辑划分，每个数据库至少有一个表空间(称作SYSTEM表空间)。为了便于管理和提高运行效率，可以使用一些附加表空间来划分用户和应用程序。例如：USER表空间供一般用户使用，RBS表空间供回滚段使用。\n```\n//创建表空间：\n//Create TableSpace 表空间名称\n//       DataFile 表空间数据文件路径\n//       Size 表空间初始大小\n//       Autoextend on\ncreate tablespace db_test\n        datafile 'D:\\oracle\\product\\10.2.0\\userdata\\db_test.dbf'\n        size 50m\n        autoextend on;\n```\n\n### \"用户\"\n数据库创建完成后，要想在数据库里创建表，必须为数据库建立用户，并为用户指定表空间。\n```\nCREATE USER aaa   //用户名\n       IDENTIFIED BY aaa123   //密码  \n       DEFAULT TABLESPACE db_test   //设置表空间\n```\n\n## 用户赋权\n创建用户，指定表空间之后，如果想要让该用户操作数据库，还需要给用户赋权。\n\n### 权限分类\n`Connect`：临时用户角色\n`Resource`：正式用户角色\n`DBA`：管理员（一般不用）\n\n### 赋权基本语句\n**赋予角色：**\n`Grant connect,resource to aaa`\n**撤销角色：**\n`Revoke connect,resource from aaa`\n**删除（撤销）用户：**\n`DROP USER 用户名` \n`DROP USER 用户名 CASCAED  //CASCAED表示删除用户的同时删除其建立的实体`\n**操作赋权：**\n`Grant select on scott.db_test to aaa //将查询scott用户的db_test表的权限授予aaa用户`\n\n> 文章内容主要来源：https://blog.csdn.net/qq_38986609/article/details/82501643","tags":["Oracle"],"categories":["Oracle"]},{"title":"关于Tomcat运行的一点错误","url":"%2F2019%2F02%2F26%2Flogan12tomcat_error%2F","content":"最近用到多个版本的Tomcat时，出现了以前刚接触Tomcat时遇到的闪退现象。\n<!-- more -->\n以前配置Tomcat时也遇到过类似的错误，但是同样的方法并没有解决，最后发现这几次主要都是因为`JRE_HOME`的环境变量不正确。\n> 如果想要查看闪退的错误信息，可以在cmd中切换到bin路径下执行`startup.bat`\n\n![](https://i.imgur.com/0T2La5f.png)\n\n配置`JRE_HOME`所在的位置就是`bin\\setclasspath.bat`，打开`setclasspath.bat`找到如图所示的位置：\n![](https://i.imgur.com/AhC9Kkn.png)\n错误很明显，这里已经直接指定了jdk的路径，因此解决方法可以是：\n**删除指定的路径代码或者将指定的路径改成正确的路径**\n再次运行startup.bat即可。\n","tags":["Tomcat"],"categories":["Tomcat"]},{"title":"我的2018","url":"%2F2018%2F12%2F31%2Flogan11summaryof2018%2F","content":"\n岁末将至，2018年马上过去。\n刚刚结束了学校里的课程，离开学校前还有大大小小的事情要做。\n年终总结不知不觉就被拖到了2018的最后一天，\n回顾2018这一年，身边发生了许多的事情，\n对于自己来说2018也是人生中最重要最值得铭记的一年。\n\n<!-- more -->\n\n## 那些人\n\n2018年最值得记录的就是身边一个又一个可爱的人，在这一年，认识了很多的朋友，有同一学校不同专业的`阿RUI`，一起呆了几个月懂得很多玩游戏也贼6的`老梁`，第一感觉有点小猥琐但人超好的`阿豪`；关于老朋友，有的许久不联系但路上偶遇总能兴致勃勃地谈一路，当然也包括那几个天天骂来骂去但喝酒绝不认怂的`舍友`。\n\n还有那些令人尊敬的老师，无论是校外校内，他们亦师亦友，教会了我太多东西。\n\n## 那些日子\n\n### 迷茫着\n\n2018年的前几个月，过得实在是非常迷茫，总结成一个字：`丧`，每天跟着学校的课程，剩下的时间没有目的地去虚度，做过`兼职`；偶尔跟朋友`约饭`；在这期间把`python`的基础语法学了一遍，尝试着写了一个小`demo`。\n![](https://i.imgur.com/3XKuh5O.jpg)\n\n### 努力着\n\n确定方向后事情就简单的多了，尽最大的努力去做就行了。\n\n暑假前申请留校开始准备校招，9月底开始校招之旅，记得第一次是在本校参加一个省内软件公司的宣讲会，抱着试一试的态度，没有准备纸质简历，现场做了40分钟的笔试题，到场的人并不多，面试官看完笔试之后开始问问题，持续了20几分钟，每一个问题都弄得我一脸尴尬。首战告败（虽然最终给了offer，但是公司位置待遇都不太合适），真正让我懂得要学的东西还有太多。\n\n之后的一个月，每一天都是在早上起床查看邮件，规划行程，奔波在从一个学校到另一个学校的路上，每天路上的时间超过5个小时，晚上在地铁上总结今天的收获。一场场宣讲会听下来，一场场笔试做下来，一次又一次的技术面、Hr面，笔试面试的经验多了，手里的offer也多了。每一场下来都有学到很多东西，也知道自己的短板在哪里。\n\n站在年末回想起这奔波的40天，只能用`充实`、`忙碌`、`难忘`来描述。\n\n## 说点别的\n\n~~** 脸大了 **~~\n\n~~体重并没有涨很多，但是脸为什么大了呢（可能肉只长脸上了）？虽然承认从小一直是头大，但是给别人的感觉也胖了....hahahahahahha~~\n\n** 少熬夜，多走走 **\n\n熬夜就不要熬夜了，这辈子是不想熬夜。这一年基本都是23点-24点之间入睡（失眠、重要时刻除外）。\n\n千万不要久坐，深有体会。暑假8月份天天坐着写代码，然后肠胃炎反反复复半个多月，真的很难受。\n\n## 去年的目标实现了吗？\n\n写这篇年终总结的时候，我一直在想去年我有立下Flag吗？\n![真的是去年的summary](https://i.imgur.com/qAJg1uW.png)\n好像还真没有确切的`KPI`，那就不要脸的都算完成了吧。\n\n## 说说2019的小目标\n\n每到年末必然要展望新的一年，立下新的Flag。\n好，列一下2019年的小目标：\n- 家人朋友健康平安\n- 大学画一个圆满地句号\n- 掌握几个框架，包括但不仅限于`AngularJS`\n- 补一下自己的短板，包括但不仅限于`算法及数据结构`\n- 多读书，买的书一定要好好利用\n- 去不同的城市走一走（毕业旅游或者工作之余）\n- 多运动，走一走\n- 博客每月>=2篇\n- 好好工作，努力学习技术\n- 写一个自己喜欢的项目\n\n暂时想到这些，其他目标随时增加。\n\n> 2019，keep going！ \n> Hello SH！","tags":["年终总结"],"categories":["年终总结"]},{"title":"将bolg同时部署到github和coding","url":"%2F2018%2F11%2F30%2Flogan10blog2%2F","content":"第一次通过Hexo搭建博客的时候，托管在了Github，访问速度还算可以，但是最大的问题是网站收录问题。\n建站当天Google就收录了站点，因为Github禁止了百度蜘蛛爬取，所以百度无法收录。所以要解决收录问题可以同时部署在Github和coding，国内的用户访问coding，国外访问Github。\n<!-- more -->\n上篇文章已经写了如何通过Hexo+Github搭建blog，可以参考：[通过Hexo+Github搭建个人bolg](http://loganwz.com/2018/11/29/logan09blog/)\n这篇文章主要介绍`部署到coding`及`域名解析`\n\n## 准备工作\n** 1.新建coding仓库 **\n注册coding账号，使用方式与Github相似，新建一个仓库\n仓库命名规则与Github稍有不同，仓库名直接与coding账号名称相同即可，同样是为了避免二级域名\n** 2.添加SSH **\n找到你的`id_rsa.pub`文件，复制公钥内容，找到coding账号`个人设置`下的`SSH公钥`,新增公钥粘贴进去即可\n![](https://i.imgur.com/r3lC3N3.png)\n继续输入`ssh -T git@git.coding.net`![](https://i.imgur.com/ShyzkqD.png)\n出现以上信息代表添加成功\n\n## 部署\n** 1.修改配置文件 **\n复制coding中新建仓库的SSH连接\n![](https://i.imgur.com/fz8zKG6.png)\n打开博客文件夹下的`_config.yml`全局配置文件，修改样式如下，将复制的coding仓库的SSH连接粘贴到对应位置\n![](https://i.imgur.com/9GFyqZZ.png)\n修改好后保存配置文件\n** 2.同时部署到Github和coding **\n继续输入命令`hexo d`就同时推送到了两个远程仓库\n刷新coding仓库就能看到推送上来的内容了\n选择coding仓库`代码`选项下的`Pages服务`，开启Pages即可\n![](https://i.imgur.com/IjGjyu8.png)\n>**注意：**在博客source/目录下需要创建一个名为`Staticfile`的空白文件,因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。\n\n## 设置域名解析\n![](https://i.imgur.com/EvMkIZT.png)\n分别ping了托管到的两个地方，可以明显看出coding访问要快一些，加上coding能被百度蜘蛛爬取的特点，所以要设置域名解析\n** 1.购买域名 **\n通过阿里云购买即可\n** 2.域名解析 **\n在阿里云账号控制台中添加域名解析，域名解析设置可以参考下图：\n![](https://i.imgur.com/MQVf15W.png)\n解析后等待一会就可以访问。\n","tags":["Github"],"categories":["Hexo"]},{"title":"通过Hexo+Github搭建个人bolg","url":"%2F2018%2F11%2F29%2Flogan09blog%2F","content":"今天是距离博客初次搭建已经123天\n下午捣鼓着差点把博客弄崩\n`hexo d`之后无法自动生成文章归档信息<!-- more -->\n搞了半天原来之前误删了之前的一些插件\n其实可以通过`npm ls --depth 0`查看缺少那些插件\n![](https://i.imgur.com/jNBTS5I.png)\n总结了一下当时通过Hexo搭建静态博客的步骤\n防止以后再次采坑！\n## 准备工作\n### 安装Git\n无论使用那个平台托管，都是需要Git 来进行代码管理\n使用配置参考之前的文章：[Git(一)：关于Git的配置使用及常见问题](http://loganwz.com/2018/08/03/logan02Git/ \"Git(一)：关于Git的配置使用及常见问题\")\n### 安装node.js\nNode.js 的是一个JavaScript 运行环境,这里我们主要使用它来生成我们博客的静态页面。从官网下载最新的安装包进行默认安装就好。\n### 其他准备工作\n准备到现在，基本可以开搞，不过博客搭建起来肯定是要发表文章，那么还需要一个markdown编辑器（推荐`MarkdownPad2`,自带图床比较方便）\n### 新建github项目\n一般通过Hexo 搭建的博客可以托管在Github 上，Github 为每位用户提供了Github Page 服务。\n首先要在你的Github 上新建仓库\n命名规则应该按照`username.github.io`，其中`username`指的Github 账号名\n> 尽量按照命名规则进行命名，如果用其他的来命名会产生二级域名\n\n## 搭建开始\n** 1.安装hexo **\n鼠标右键运行`Git Bash Here`\n然后输入`npm install hexo`\n![](https://i.imgur.com/1rfrjEy.png)\n出现如图结果就代表安装成功\n** 2.执行hexo命令 **\n新建一个空白文件夹，cd切换到该文件夹，依次执行以下命令\n```\nhexo init   //初始化hexo环境，会生成一些hexo的文件\nnpm install //安装所需要的npm依赖\nhexo generate //生成静态页面\nhexo server   //生成本地预览\n```\n执行完最后一步，访问http://localhost:4000如果出现页面说明已经搭建成功\n## 部署到远程仓库\n在上一步中，搭建的博客已经能在本地访问，下一步就是部署到远程仓库，让大家都能访问到\n**1.配置_config.yml**\n找到新建文件夹下面的`_config.yml`，这是博客的全局配置文件\n找到`deploy`,改成如下格式\n```\ndeploy:\n  type: git\n  repo：git@github.com:username/username.github.io.git\n  branch: master\n```\n`username`换成自己的用户名（如果按照上面命名规范来的话）\n最后在执行`hexo deploy`\n现在就可以在浏览器中访问http：//username.github.io了\n## 其他一些小知识\n`hexo clean`可以用来清除缓存，运行之后就可以清除上次生成的静态页面文件\n以下命令都可以缩写\n```\nhexo generator  --> hexo g\nhexo server  --> hexo s\nhexo deploy --> hexo d\n```","tags":["Github"],"categories":["Hexo"]},{"title":"遍历Map的几种方法","url":"%2F2018%2F11%2F14%2Flogan08map%2F","content":"好久更新博客，前段时间校招真是心疲力竭（主要还是太菜...）\n面试中被问到Map的遍历方法,基本上没答出来\n根据网上的文章整理了Java中Map的几种遍历方法\n<!-- more -->\n### 通过for-each循环使用entry遍历key和value ###\n**大多数情况下使用最常见，在键值都需要时使用**\n```\n\tMap<String, Integer> map = new HashMap<>();\n\tmap.put(\"a\", 1);\n\tmap.put(\"b\", 2);\n\tmap.put(\"c\", 3);\n\tfor(Map.Entry<String,Integer> entry : map.entrySet()) {\n\t\tSystem.out.println(\"key = \" + entry.getKey() + \", value=\" + entry.getValue());\n\t}\n```\nfor-each循环在Java5中被引用，所以只能适用于5及以上版本；\n遍历前应该检查map是否为空，遍历空集合的话会抛出NullPointerExcption\n### 在for-each循环中分别遍历keys或values ###\n```\n\tfor(String key : map.keySet()) {\n\t\tSystem.out.println(\"key = \" + key);\n\t}\n\t\t\t\n\tfor(Integer value : map.values()) {\n\t\tSystem.out.println(\"value = \" + value);\n\t}\n```\n### 使用Iterator遍历 ###\n使用泛型：\n```\n\tIterator<Map.Entry<String, Integer>> entries = map.entrySet().iterator() ;\n\twhile (entries.hasNext()) {\n\t\tMap.Entry<String, Integer> entry = entries.next();\n\t\tSystem.out.println(\"key = \" + entry.getKey() + \", value = \" + entry.getValue());\n\t}\n```\n不使用泛型：\n```\nIterator entries = map.entrySet().iterator();\nwhile (entries.hasNext()) {\n\tMap.Entry entry = (Entry) entries.next();\n\tString key = (String)entry.getKey();\n\tInteger value = (Integer) entry.getValue();\n\tSystem.out.println(\"key = \" + key + \", value = \" + value);\n}\n```\n这种方法是在Java老版本中唯一的遍历map的方法。在遍历的同时可以通过`iterator.remove()`来删除entry。\n### 通过键找值遍历 ###\n```\nfor(String key : map.keySet()) {\n\tInteger value = map.get(key);\n\tSystem.out.println(\"key = \" + key + \", value = \" + value);\n}\n```\n特点：效率低","tags":["Java"],"categories":["Java"]},{"title":"单例模式","url":"%2F2018%2F09%2F17%2Flogan07Singleton%2F","content":"单例模式（Singleton）是一种常见的设计模式，是指类的一个对象在系统中只有一个实例。\n<!-- more -->\n## 单例模式有很多应用场景\n- Windows系统中的`任务管理器`和`回收站`就是典型的单例模式，无论在什么位置打开，系统中始终只有一个任务管理器和回收站。\n- 网站中的`计数器`一般也是采用单例模式，否则难以同步。\n- 应用程序的`日志应用`，一般都使用单例模式实现，从而方便内容追加。\n\n## 单例模式的三要素\n> - 私有的构造方法；\n> - 指向自己实例的私有静态引用；\n> - 以自己实例为返回值的静态的公有方法。\n## 单例模式的作用\n> 保证一个类只有一个实例，并且提供一个访问该实例的全局站点。\n## 单例模式的实现\n如果想要保证只有一个实例，就要保证外界不能随便new这一个对象，因此要将`构造方法私有化`。\n> 私有化构造方法即将new这个对象的权限收回，只能在这个类的内部去实例化这个对象。\n## 单例模式的两种常见形式\n### \"懒汉式\"\n> `\"懒汉式\"`顾名思义就是很懒的意思，只有在需要某个类的实例的时候才会执行，new出唯一的一个对象。\n#### \"懒汉式\"示例\n```\npublic class Singleton1 {\n   //定义一个变量来存储创建好的类实例\n   //因为这个变量要在静态方法中使用，所以需要加上static修饰\n   private static Singleton1 instance = null;\n   \n   //私有化构造方法，好在内部控制创建实例的数目\n   private Singleton1() {\n      \n   }\n   \n   //定义一个方法来为客户端提供类实例\n   //这个方法需要定义成类方法，也就是要加static\n   public synchronized static Singleton1 getInstance() {\n      //判断这个实例是不是有值\n      if (instance == null) {\n         //如果没有，就创建一个类实例，并把值赋给存储类实例的变量\n         instance = new Singleton1();\n      }\n      return instance;\n   }\n}\n```\n#### \"懒汉式\"单例模式特点\n> `以时间换空间：` 延迟加载，在需要的时候才实例化对象，节省了部分空间，避免了因为没有使用而造成的浪费。\n> `线程安全性：`不安全，可能会存在同时调用构造方法，当第一次调用时运行入构造方法，判断实例为null，在即将要实例的时候，cpu切换到第二次调用，又进入构造方法同时判断为null并成功实例化，这时候再返回第一次调用同样也进行了实例化，但这样会return两个不同的实例对象，造成线程安全问题（类似于银行取钱）。解决方法：`加锁synchronized`\n### \"饿汉式\"\n> `\"饿汉式\"`顾名思义是饥渴难耐，在类被加载的时候立即实例化一个对象。\n#### \"饿汉式\"示例\n```\npublic class Singleton2 {\n   //定义一个变量来存储创建好的类实例\n   //直接在这里创建类实例，由虚拟机来保证只会创建一次\n   //这个类加载到内存的时候就会创建唯一的一份实例\n   private static final Singleton2 instance = new Singleton2();\n   \n   //私有化构造方法，好在内部控制创建实例的数目\n   private Singleton2() {\n      \n   }\n   \n   //定义一个方法来为客户端提供类实例\n   //这个方法需要定义成类方法，也就是要加static\n   public static Singleton2 getInstance() {\n      //直接使用已经创建好的实例\n      return instance;\n   }\n}\n```\n#### \"饿汉式\"单例模式特点\n> `以空间换时间：` 立即加载，在加载类的时候就会立即实例化一个对象。时间上没有延迟，但可能会造成实例化的对象没被使用从而对导致空间资源浪费。\n> `线程安全性：` 安全的","tags":["设计模式"],"categories":["Java"]},{"title":"基础知识(一):Java部分","url":"%2F2018%2F09%2F17%2Flogan06java%2F","content":" 本文包括Java基础的一些问题，由网上的资料整理所得。内容多，不定时整理更新。\n<!-- more -->\n# Java基础部分\n## Java跨平台原理\n因为`JVM（java虚拟机）`能够跨平台安装，不同系统、不同版本、不同位数的JVM帮助开发者屏蔽了操作系统的不同，使得相应的字节码可以在任何平台上运行。\n\n## Java中的基本数据类型\n|数据类型|位数|范围|默认值|\n|:---:|:---:|:---:|:---:|\n|byte(字节)|8|-128~127|0|\n|short(短整型)|16|-32768~32768|0|\n|int(整型)|32|-21亿~21亿|0|\n|long(长整型)|64|-2^63~2^63-1|0|\n|float(浮点型)|32||0.0f|\n|double(双精度)|64||0.0d|\n|char(字符型)|16|\\u0000~\\uffff|\\u0000|\n|boolean(布尔型)|1|true/false|false|\n> `byte->short(char)->int->long->float->double`\n> 从小到大自动类型转换\n> 从大到小需要强制类型转换，可以会丢失精度\n\n## 包装数据类型\n|基本数据类型|包装数据类型|\n|:---:|:---:|\n|int|Integer|\n|char|Character|\n|double|Double|\n|long|Long|\n|short|Short|\n|boolean|Boolean|\n|byte|Byte|\n基本数据类型和包装数据类型之间可以通过`装箱（把基本的数据类型转换成对应的包装类型）`和`拆箱（把包装类型转换为基本数据类型）`相互转换。\nJava是面向对象的语言，基本数据类型不具备面向对象的特性。\n\n## String和StringBuffer、StringBuilder的区别\n`String`是内容不可变的字符串\n>String底层使用了一个不可变的字符串数组`final char[]`,因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响。\n\n`StringBuilder(线程不安全) StringBuffer(线程安全)`是内容可以改变的字符串\n>StringBuilder StringBuffer底层使用的是可变的字符数组（没有用final修饰），每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。一般情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。\n\n**三者的区别：**\n拼接字符串时：\n```\n//String进行拼接：\nString c = \"a\" + \"b\" \n```\n```\n//StringBuffer或StringBuilder拼接时：\nStringBuilder c = new StringBuilder();\nc.append(\"a\").append(\"b\");\n```\n**三者效率：**\n`StringBuilder>StringBuffer>String`\n>  `Java.lang.StringBuffer`线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。\n>  可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。\n>  StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n>  例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n>  `java.lang.StringBuilder`一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。\n\n## Java中的集合\n![](https://i.imgur.com/zVjNHOm.png)\nJava中的集合分为：Conllection和Map（即value，key-value）两种\n\n### Collection接口\n> Collection接口是集合类的跟接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是`Set`和`List`。\n\n**List是有序的，可以重复。**\n  List中常用的ArrayList和LinkedList的区别和使用场景：\n  - ArrayList底层使用的是`数组`，数据查询特定元素比较快，而插入、删除和修改比较慢（数组在内存中是一块连续的内存，插入、删除需要移动内存）\n  - LinkedList使用的是`链表`，查询效率低（查询需要从头开始，一个一个地找），而插入、删除的效率高（插入是不需要移动内存，只需要改变引用只想即可）\n\n**Set是无序的，不可以重复。**\n根据equals和hashcode判断，也就是如果一个对象要存储在Set中，必须要重写equals和hashcode方法。\n\n### Map接口\n\n## HashMap哈HashTable的区别?HashTable和ConcurrentHashMap的区别？\n相同点：HashMap和HashTable都可以用来存储Key-value的数据\n不同点：\n1.HashMap可以把null作为Key或者value的，而HashTable不可以\n2.HashMap是线程不安全的，效率较高；而HashTable是线程安全的，效率较低。\n**如果既要线程安全又要效率高？**\n可以通过把整个Map分为N个Segment（类似于HashTable），操作前面的而不影响后面的使用，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。\n\n## 线程的几种实现方式?启动方式？区分方式？\n**线程的实现方式**\n1.通过继承Thread类实现一个线程\n2.通过实现Runnable接口实现一个线程\n两者区别：Java是单继承的，继承Thread类方式将单继承位置占了。这个时候只能去实现接口，不能再去继承别的类。而实现Runnable接口的方式不影响类的继承。\n**线程的启动方式**\n```\n//继承Tread方式\npublic class MyThread extends Thread{\n\t@override\n\tpublic void run(){\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n}\n\npublic static void main(String[] args){\n\t//继承了Thread的对象\n\tMyThread myThread = new MyThread();\n\t//不是启动线程，只是调用对象里面的普通的run（）方法\n\tmyThread.run();\n\t//真正启动一个线程调用start（）方法，执行的就是run方法里面的内容\n\tmyThread.start();\n}\n\n//实现Runnable接口方式\npublic class MyRunnable implements Runnable{\n\t@override\n\tpublic void run(){\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tSystem.out.println(i);\n\t\t}\n\t} \n}\n\npublic static void main(String[] args){\n\t//实现Runnable接口的对象\n\tMyRunnable myRunnable = new MyRunnable();\n\tThread thread = new Thread（myRunnable，\"线程名字\"）；\n\tthread.start();\n}\n```\n\n**线程的区分方式**\n>`thread.setName(\"设置线程的名称\")`这是一种规范，在创建线程之后，都需要设置名称。\n\n## 有没有使用过线程并发库?\n> JDK5中增加了Doug Lea的并发库，这一引进给Java线程的管理和使用提供了强大的便利性。 java.util.current包中提供了对线程优化、管理的各项操作，使得线程的使用变得的心应手。该包提供了线程的运行，线程池的创建，线程生命周期的控制.\nJava通过Executors提供四个静态方法创建四种线程池，分别为：\nnewCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\nnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\nnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\nnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\n\n## 线程池的作用\n1.限定线程的个数，不会导致由于线程过多而导致系统运行缓慢或崩溃\n2.线程池不需要每次都去创建或销毁，节省了资源\n3.线程池不需要每次都去创建，响应时间更快\n\n## 常用的设计模式有哪些？\n> 设计模式是经过前人无数次的实践总结出来的，在设计过程中可以反复使用的、可以解决特定问题的设计方法。\n\n**单例模式**\n参考文章：[单例模式（“饱汉式”和“饿汉式”）](http://loganwz.com/2018/09/17/logan07Singleton/ \"单例模式（“饱汉式”和“饿汉式”）\")\n**工厂模式**\nSpring IOC就是使用了工厂模式，对象的创建交给一个工厂去做。\n**代理模式**\nSpring AOP就是使用的动态代理。\n\n# Java Web部分\n## http中get和post请求的区别？\n>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息\n\n**GET**\n1.采用URL请求路径传输参数。参数拼接 在URL后面。\n2、参数传输过程中隐私性较差，直接在URL后面。\n3、路径可以容纳的数据有限，只能传递少量参数。\n4、所有请求默认就是get。\n**POST**\n1、采用实体内容传参数。\n2、参数在传输过程中不可见，隐私性好。\n3、实体内容专门用来传输数据，大小没有限制。\n4、使用：在form上加method=\"post\"\n\n## Servlet\n### 什么是Servlet？\nServlet是用Java编写的服务端程序，主要功能在于交互式地浏览和修改数据，生成`动态web内容`。Servlet运行于支持Java的应用服务器中。是sun公司提供的一套规范(接口),用来处理客户端的请求、响应动态资源给浏览器的。\nServlet实质就是java代码，通过java的API动态的向客户端输出内容。\n\n### Servlet的生命周期\nServlet的生命周期包括`加载`和`实例化、初始化、处理请求`以及`服务结束`\n>`init()`：\n在Servlet的生命周期中，仅执行一次init()方法。它是在服务器装入Servlet时执行的，负责初始化Servlet对象。可以配置服务器，以在启动服务器或客户机首次访问Servlet时装入Servlet。无论有多少客户机访问Servlet，都不会重复执行init（）。\n`service()`：\n它是Servlet的核心，负责响应客户的请求。每当一个客户请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。在HttpServlet中已存在Service()方法。默认的服务功能是调用与HTTP请求的方法相应的do功能。\n`destroy（）`：\n仅执行一次，在服务器端停止且卸载Servlet时执行该方法。当Servlet对象退出生命周期时，负责释放占用的资源。一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成。\n\n**Servlet工作的步骤：**\n1.Web Client 向Servlet容器（Tomcat）发出Http请求\n2.Servlet容器接收Web Client的请求\n3.Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。\n4.Servlet容器创建一个HttpResponse对象\n5.Servlet容器调用HttpServlet对象的service方法，把6.HttpRequest对象与HttpResponse对象作为参数传给HttpServlet 对象。\n7.HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。\n8.HttpServlet调用HttpResponse对象的有关方法，生成响应数据。\n9.Servlet容器把HttpServlet的响应结果传给Web Client。\n\n### Servlet中转发和重定向的区别\n1.转发是服务器端的转向，重定向是客户端的跳转\n2.转发浏览器的地址不会发生改变，重定向浏览器地址会发生改变\n3.转发是在一次请求中完成，重定向是重新发起请求\n4.转发是在服务器端完成，而不用客户端重新发起请求，效率较高\n\n## JSP\n### 什么是JSP\nJSP就是一个servlet程序，servlet的技术可以用在jsp程序中，但是jsp的技术并不是全部适用servlet程序。\njsp继承servlet。\n\n### JSP的内置对象及作用\n**Jsp中的四个域对象**\n\n|域对象|作用范围|\n|:---:|:---:|\n|pageContext|page域|\n|request|request域|\n|session|sesion域|\n|application|context域|\n1、域对象的作用：\n保存数据和获取数据，用于数据的共享。\n2、域对象方法：\n```\nsetAttribute(\"name\", Object);//保存数据\ngetAttribute(\"name\");//获取数据\nremoveAttribute(\"name\");//清除数据\n```\n3、域对象的作用范围:\npage域：只能在当前jsp页面使用（当前页面） \nrequest域：只能在一次请求中使用（转发）\nsession域：只能在同一个会话中使用（会话，私有的）\ncontext域（application域）：只能在同一个web应用中使用（全局的）\n\n## Session和Cookie的区别\n>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).\n\n**cookie 和session 的区别：**\n1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。\n3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。\n4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n5、所以尽量：\n   将登陆信息等重要信息存放为SESSION\n   其他信息如果需要保留，可以放在COOKIE中，比如购物车\n购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。","tags":["编程语言"],"categories":["Java"]},{"title":"Git(二):版本回退及分支","url":"%2F2018%2F08%2F26%2Flogan05Git(2)%2F","content":"\n关于Git版本控制更加深入一点的知识，详细初始使用请查看上一篇：[关于Git的配置使用及常见问题](http://loganwz.com/2018/08/03/logan02Git/ \"关于Git的配置使用及常见问题\")\n本文主要包括版本回退及分支相关内容。\n<!-- more -->\n# 版本回退\n- `git reset --hard HEAD^`回退到上一版本\n- `git reset --hard HEAD^`回退到上上版本\n- `git reset --hard HEAD~100`回退到上100个版本\n- `git reset --hard 具体版本号`回退到具体版本号\n记录每一次命令：`git reflog`\n`git checkout -- readme.txt`：\n命令`git checkout -- readme.txt`意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：\n一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一`次git commit`或`git add`时的状态。\n\n# 删除\n删除文件后，Git知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了：\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm filename` 删掉，并且`git commit`\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： `git checkout -- filename`\n\n# 分支\n- `git branch 分支名`：创建分支\n- `git checkout 分支名`：切换分支\n- `git checkout -b 分支名` ：创建与切换同时进行\n- `git branch `：列出所有分支\n- `git merge dev `：把dev分支的工作成果合并到master分支上\n- `git branch -d 分支名` : 删除分支\n\n# 分支策略\n在实际开发中，我们应该按照几个基本原则进行分支管理：\n首先，`master`分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n那在哪干活呢？干活都在`dev`分支上，也就是说，`dev`分支是不稳定的，到某个时候，比如1.0版本发布时，再把`dev`分支合并到`master`上，在`master`分支发布1.0版本；\n你和你的小伙伴们每个人都在`dev`分支上干活，每个人都有自己的分支，时不时地往`dev`分支上合并就可以了。\n所以，团队合作的分支看起来就像这样：\n![](https://i.imgur.com/zwosVyW.png)\n\n# 多人协助\n![](https://i.imgur.com/OMHN1l4.png)\n\n本文作者：`rottengeek`\n原文链接：https://segmentfault.com/a/1190000016012022","tags":["Git"],"categories":["Git"]},{"title":"markdown基本语法","url":"%2F2018%2F08%2F13%2Flogan03markdown%2F","content":"# markdown介绍\n\n作为一种轻量级的**标记语言**，专门用来编写文档，markdown的语法十分简单。通过markdown编辑器可以实时查看文档的效果，可以非常方便的进行写作和日后查阅。\n<!-- more -->\n# 基本语法\n## 标题\n\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n![](https://i.imgur.com/SuUHOV2.png)\n（图片指令对应效果如上）\n\n## 字体样式\n\n粗体的语法是：用在需要使用粗体显示的文本前后各加两个*或者_。\n斜体 标记语法是：在需要使用斜体显示的文本前后各加一个*或者_\n\n## 分割线\n\n在一个空白行中连续输入三个以上的 *(星号)、-（减号）或者_(底线）来实现，该行不允许有其他文字。\n\n## 删除线\n\n要加删除线的文字左右分别添加~~\n\n## 引用\n\n在要引用的文字前加>，>必须位于一行的行首\n可以多层引用，只需要将>递增\n>这是引用\n## 超链接\n\n使用格式：\n     [超链接名](超链接地址 \"超链接title\")\n\t title可加可不加\n实例：\n![](https://i.imgur.com/E0XF7KA.png)\n\n## 列表\n### 无序列表\n\n无序列表用 - + * 任何一种都可以\n只需要加在列表项之前\n示例：\n![](https://i.imgur.com/MXjDvrF.png)\n显示效果：\n- 列表内容\n+ 列表内容\n* 列表内容\n\n### 有序列表\n\n有序列表为数字加列表内容\n![](https://i.imgur.com/UHeXxdW.png)\n效果：\n1.列表内容\n2.列表内容\n3.列表内容\n### 列表嵌套\n\n1.一级列表内容\n   1.二级列表内容\n   2.二级列表内容\n有序无序都可以适用\n## 表格\n\n![](https://i.imgur.com/uCxqoxQ.png)\n第二行分割表头和内容。\n- 有一个就行，为了对齐，多加了几个\n文字默认居左\n-两边加：表示文字居中\n-右边加：表示文字居右\n效果：\n\n|表头|表头|表头|\n|:-:|:-:|:-:|\n|内容|内容|内容|\n|内容|内容|内容|\n## 代码\n![](https://i.imgur.com/p7xZukj.png)\n**效果如下：**\n单行代码：\n`代码内容`\n多行代码：\n```\n  代码\n  代码\n  代码\n```","tags":["markdown"],"categories":["工具"]},{"title":"写在前面","url":"%2F2018%2F08%2F04%2Flogan01%2F","content":"\n# 建站初衷 #\n![](https://i.imgur.com/JStFGVh.jpg)\n<!-- more -->\n每个人都应该有自己的创作平台，之前运营社团公众号的时候就想找一个平台写一些自己的东西，起初选择了微信公众号，写了几篇之后觉得不太喜欢就没再坚持下去。\n\n后来成了印象笔记的忠实用户，笔记写起来很方便但是当笔记多了之后管理起来很杂乱。\n\n最终我还是决定开一个自己的博客，因此就有了这个用hexo搭建的静态博客，目前部署在github上。\n\n目前博客主要用来记录自己的日常学习和生活。\n","tags":["随笔"],"categories":["随笔"]},{"title":"Git(一)：关于Git的配置使用及常见问题","url":"%2F2018%2F08%2F03%2Flogan02Git%2F","content":"Git作为版本控制工具，学会并掌握它的使用方法是非常有必要的。网上很多关于Git的教程也写的非常详细，为了加深理解以及能给其他人提供帮助，今天写一下Git的使用和配置问题。\n<!-- more -->\n# Git的使用 #\n通过Git你能够很容易的管理你的本地库以及同步coding/github上的远程库。\n关于Git的安装在这里就不再赘述，网上有很详细的介绍。\n## 登录 ##\n下载完成在电脑上安装Git之后，点击鼠标右键你会发现多了两个按钮\"Git Gui Here\"和\"Git Bash Here\"，我们用到的就是第二个，点击它之后会出现这个界面：\n![](https://i.imgur.com/bpMvmRB.png)\n我们现在要做的就是登录它了，\n在光标处依次输入：\n>`git config --global user.name “Your Name”` \n>`git config --global user.email “email@example.com”`\n`\"yourname\"`和`\"email@example.com\"`是要输入你自己的姓名和邮箱。这个只是作为你的登录凭证，不是必须要跟github账号一样。\n当你输入完成之后就可以进行一些操作了。\n## 本地库的操作 ##\n选择你要处理的已经有的本地项目文件夹，进入文件夹之后点击鼠标右键，选择Git Bash Here之后会出现如下界面\n![](https://i.imgur.com/SyzBj3l.png)\n>`git add aa.txt`\n>//添加操作：将新建的aa.txt文件提交到暂存区中\n>`git status`\n>//查看操作：查看当前状态\n>`git commit -m\"`你自己写的提交信息\"\n>//提交操作：将文件从暂存区提交到本地库\n## 新建一个本地库 ##\n\n如果我们想要新建一个项目的本地库的话，需要执行下面的这些操作：\n假设我在桌面有一个叫 `\"wz\" `的空文件夹,我们现在进入这个文件夹，右键`Git Bash Here`，然后输入:\n![](https://i.imgur.com/K1Rw6Ep.png)\n>`mkdir wang`\n这时我们就在`wz`文件夹内新建了一个名为`wang`的文件夹，我们就把他当做要建立的新项目，\n![](https://i.imgur.com/LuLXP1Z.png)\n>`cd wang`\n进入到了`wang`文件夹（以上两条命令都是linux指令，因为git就是基于linux命令来执行的）\n![](https://i.imgur.com/XaZzVEW.png)\n>`git init`\n这时所在项目文件夹中会出现一个名为`.git`的隐藏文件，这表明你可以操作本地库了。\n>`git add .`\n>`git status`\n>`git commit -m\"\"`\n操作本地库的指令在上面已经介绍过了，这样的话，本地操作已经基本完成了。接下来就是同步到远程库了\n## 同步到远程库 ##\n学会了管理本地库，同步到远程库也就很简单了。在这里就以同步到`github`上为例（`github`中`repository`的新建和配置网上有很详细的过程，操作也很简单）\n### 创建SSH ###\n第一次用`Git`管理远程库需要创建`SSH`\n![](https://i.imgur.com/iYeMK5V.png)\n>`ssh-keygen -t rsa -C \"你的邮箱\"`\n邮箱是注册Github是留的邮箱，输入命令之后连续回车会出现上图界面，这表示已经创建成功。\n### 添加SSH到github ###\n![](https://i.imgur.com/rivv9TO.png)\n进入github个人账户的`settings`中，找到如图所示位置，将创建SSH后生成的`id_rsa`文件复制后，选择`New SSH key`，粘贴进去，文件名随便。\n### 测试SSH是否成功 ###\n输入\n>`ssh -T git@github.com`\n//注意是git@github.com，不是你的邮箱。\n会提示你：\n>The authenticity of host ‘github.com (192.30.255.112)’ can’t be established. \n>RSA key fingerprint is >SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. \n>Are you sure you want to continue connecting (yes/no)?\n正常提示，你只需要YES就可以。如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，如果你没设置密码会提示你：\n>`Warning: Permanently added ‘github.com,192.30.255.112’ (RSA) to the >list of known hosts. `\n>`Hi “用户名”! You’ve successfully authenticated, but GitHub does not >provide shell access.`\n\n如果用户名是正确的,你已经成功设置SSH密钥。如果你看到 `“access denied”` ，者表示拒绝访问，那么你就需要使用` https `去访问。\n### 提交到远程库 ###\n将本地库的更改同步到远程库只需在管理本地库的三步基础上增加下面的指令：\n>`git push origin master `      \n//提交到远程库\n![](https://i.imgur.com/BpIADCe.png)\n这样就大功告成了！\n# 使用中常见问题 #\n紧接上文，在配置使用Git过程中遇到了很多的问题，以下是Git使用中常见的问题\n## 设置签名 ##\n>`git config --global user.name \" \"`\n>`git config --global user.email \" \"`\n在初次使用Git时需要设置签名，输入姓名和邮箱，其实这里的姓名和邮箱并不是github上的用户名和绑定的邮箱，这里要输入的签名只是为了分辨是谁在操作本地库。\n## 本地库提交不成功 ##\n最开始使用git的时候，在开始步骤管理本地库都经常出错，主要因为没有理解git的结构落下某条命令。\n![](https://i.imgur.com/tF2Ur6l.png)\ngit结构如图所示，分为`工作区`、`暂存区`、`本地库`\ngit add命令是将当前的文件临时存储在暂存区，而到了`git commit`命令才是真正的把暂存区的文件同步到了本地库。\n在这个过程中你可以随时用`git status`来查看当前的状态\n## 每次push都要输密码 ##\n每次都要输入用户名和密码，是因为采用了https的方式同步远程库。配置好SSH Key之后换用SSH方式同步就在也不用输密码了。\n## 卡住不动 ##\n提交到github过程中卡主不动，在没有其他error的前提下，可能是因为网络问题，多试几次即可。\n# 总结 #\n在配置的基础上操作本地库以及远程库的指令汇总如下：\n>`git init ` //初始空仓库时才需要\n>`git add .`  // .表示添加当前的全部文件\n>`git commit  -m  \"提交信息\"`  //“提交信息”里面换成你需要，如“first commit\"\n>`git push origin master`   \n其他的git指令可以参考[https://www.cnblogs.com/my--sunshine/p/7093412.html](https://www.cnblogs.com/my--sunshine/p/7093412.html)\n","tags":["Git"],"categories":["Git"]}]